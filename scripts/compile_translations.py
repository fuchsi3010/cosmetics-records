#!/usr/bin/env python3
"""
Script to compile .po files to .mo files.

This script compiles all translation files in the project from the human-readable
.po format to the binary .mo format that the application uses at runtime.

Usage:
    python scripts/compile_translations.py

    Or make it executable and run directly:
    chmod +x scripts/compile_translations.py
    ./scripts/compile_translations.py

What it does:
    1. Scans the locales directory for all .po files
    2. Compiles each .po file to a .mo file using Babel's mofile.write_mo()
    3. Reports success/failure for each locale
    4. Provides summary of compilation results

Directory Structure:
    src/cosmetics_records/locales/
        en/
            LC_MESSAGES/
                messages.po  <- Source (editable)
                messages.mo  <- Compiled (generated by this script)
        de/
            LC_MESSAGES/
                messages.po  <- Source (editable)
                messages.mo  <- Compiled (generated by this script)

When to run this script:
    - After editing any .po files
    - After adding new translations
    - Before committing translation changes
    - As part of the build process

Technical Details:
    - Uses babel.messages.mofile for compilation
    - Reads .po files using babel.messages.pofile
    - Binary .mo files are platform-independent
    - Compilation validates the .po file format
    - Invalid .po files will cause compilation errors

Note:
    The .mo files should be committed to the repository so that the
    application works out-of-the-box without requiring Babel to be installed.
"""

import logging
import sys
from pathlib import Path

# Configure logging for script output
logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)s: %(message)s",
)
logger = logging.getLogger(__name__)

# Import Babel modules
# WHY: Babel provides robust tools for working with gettext catalogs
try:
    from babel.messages import mofile, pofile
except ImportError:
    logger.error("Babel is not installed. Please install it with: pip install Babel")
    sys.exit(1)


def compile_po_file(po_path: Path, mo_path: Path) -> bool:
    """
    Compile a single .po file to .mo format.

    Args:
        po_path: Path to the source .po file
        mo_path: Path to the output .mo file

    Returns:
        bool: True if compilation succeeded, False otherwise

    Process:
        1. Read the .po file using pofile.read_po()
        2. Write the .mo file using mofile.write_mo()
        3. Handle any errors and report them

    Note:
        The function validates that the .po file is well-formed.
        Any syntax errors in the .po file will cause compilation to fail.
    """
    try:
        logger.info(f"Compiling: {po_path.relative_to(po_path.parents[4])}")

        # Read the .po file
        # WHY: pofile.read_po() parses the gettext catalog format
        with open(po_path, "rb") as po_file:
            catalog = pofile.read_po(po_file)

        # Write the .mo file
        # WHY: mofile.write_mo() creates the binary catalog format
        # use_fuzzy=False: Don't include fuzzy (uncertain) translations
        with open(mo_path, "wb") as mo_file:
            mofile.write_mo(mo_file, catalog, use_fuzzy=False)

        logger.info(f"  → Created: {mo_path.relative_to(mo_path.parents[4])}")
        return True

    except Exception as e:
        logger.error(f"  → Failed to compile {po_path}: {e}")
        return False


def main() -> int:
    """
    Main entry point for the compilation script.

    Returns:
        int: Exit code (0 for success, 1 for failure)

    Process:
        1. Find the project root and locales directory
        2. Scan for all .po files
        3. Compile each one to .mo format
        4. Report summary of results
    """
    # Find the project root (parent of scripts directory)
    # WHY: Makes the script work regardless of where it's run from
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    # Path to locales directory
    locales_dir = project_root / "src" / "cosmetics_records" / "locales"

    if not locales_dir.exists():
        logger.error(f"Locales directory not found: {locales_dir}")
        return 1

    logger.info(f"Scanning for .po files in: {locales_dir}")
    logger.info("=" * 60)

    # Track compilation results
    compiled_count = 0
    failed_count = 0

    # Find all .po files
    # WHY: rglob() recursively searches for files matching the pattern
    po_files = list(locales_dir.rglob("*.po"))

    if not po_files:
        logger.warning("No .po files found")
        return 1

    # Compile each .po file
    for po_path in po_files:
        # Determine output .mo path (same directory, different extension)
        mo_path = po_path.with_suffix(".mo")

        # Compile
        if compile_po_file(po_path, mo_path):
            compiled_count += 1
        else:
            failed_count += 1

    # Summary
    logger.info("=" * 60)
    logger.info("Compilation complete:")
    logger.info(f"  ✓ Compiled: {compiled_count}")

    if failed_count > 0:
        logger.error(f"  ✗ Failed: {failed_count}")
        return 1
    else:
        logger.info("  ✗ Failed: 0")
        logger.info("")
        logger.info("All translations compiled successfully!")
        return 0


if __name__ == "__main__":
    sys.exit(main())
